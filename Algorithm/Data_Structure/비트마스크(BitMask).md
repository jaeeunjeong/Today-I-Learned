# 비트 연산
## 비트(bit)
컴퓨터에서 자료를 표현하기 위한 단위
## 사용의 이유
부분 집합이라던지 0/1 처럼 단순한 값만을 가질 때 작은 메모리와 빠른 수행시간으로 해결이 가능
## 비트 연산자
|비트연산자 기호|비트연산자 의미|
|:------:|:---:|
|&|AND|
|\||OR|
|^|XOR|
|~|NOT|
|<<|왼쪽으로 shift|
|>>|오른쪽으로 shift|
## 비트 마스크 연산 문법
1. 모든 원소 지우기  
변수를 0으로 초기화 하면 모든 값이 0이 되기에 모든 원소를 지운 것이 된다. 
```
int initZero(){
   return 0;
}
```
2. 모든 원소 초기화  
모든 원소를 포함하고자 할 때는 -1로 초기화를 통해 모든 값이 1로 만들 수 있다.
```
int initOne(){
   return -1;
}
```
3. 특정 원소 삭제하기  
특정 원소를 삭제하기 위해서는 shfit연산을 이용하여 원하는 값을 먼저 찾아준다.  
이후 not 연산을 통해 전부 값을 반전시켜주면 특정 원소를 제외하고 다 1이 된다.  
반전 된 값을 바탕으로 & 연산을 진행하면 특정 원소를 제외하고 다 이전의 값이 나오고  
특정 위치에 있는 것만 무조건 0이 되면서(값이 바뀌면서) 원하는 연산을 수행 할 수 있다.
```
int drop(int number, int idx){
   return number &= ~(1 << idx);
}
```
4. 특정 원소 포함시키기  
shift연산을 이용하여 원하는 위치의 값을 1로 만들어주고,  
| OR 연산자를 이용하여 1로 만들어준다.
```
int set(int number, int idx){
   return number |= (1 << idx);
}
```
5. 특정 원소 포함 여부 확인하기  
먼저 shift 연산을 통해 원하는 위치의 값을 1로 만들어준다.  
이후 number(찾고 싶어하는 값)과 & 연산을 통해 해당 위치가 같다면 연산의 결과의 원하는 위치가 1일 것이기에 1보다 큰 값이 된다.
```
boolean isPart(int number, int idx){
   return (number & (i << idx)) > 1;
}
```
## 비트 연산자 이용해서 부분집합 구하기
> 길이가 5인 배열의 모든 부분 집합을 구하라
```
int N = 5;
int[] arr = {20, 22, 01, 21, 48};
for(int i = 0; i < (1 << N); i++){ // 1.
   System.out.print("{");
   for(int j = 0; j < N; j++){ // 2.
      if((i & ( 1 << j)) > 0) // 3.
         System.out.print(arr[j]);
   }
   System.out.println("}");
}
```
### 주석 설명
1. shift 연산자를 이용하여 부분 집합의 갯수를 구한다.  
 부분 집합의 갯수는 2^n이기에 왼쪽 shift 연산자를 이용하여 구한다.
2. j는 자릿수를 나타낸다.
3. i가 가지는 의미는 부분 집합들을 나열하였을 때 인덱스 매기듯 만든 것.  
ex) i = 13 이라면 01011인데 N이 자리수니까  
00001, 00010, 00100, 01000, 10000 의 경우를 전부 탐색한다.  
하나라도 맞다면 & 연산의 결과가 1 이상이기에 값을 출력할 수 있다.

## SWAP
XOR 연산을 이용하면 임시 변수를 선언하지 않고 값을 교환할 수 있다.
```
int x = 20;
int y = 22;
x ^= y;
y ^= x;
x ^= y;
```

### 비트 마스킹 연습하기에 좋은 문제
https://www.acmicpc.net/problem/11723  
https://www.acmicpc.net/problem/15787
