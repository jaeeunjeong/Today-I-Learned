# Hash  
### 정의 
특정 값을 검색을 차례대로 검색하는 것이 아니라, 산술적인 연산을 통해 데이터가 있는 위치를 찾아가는 방법.  
### 시간 복잡도
평균 : O(1)  
최악 : O(n)  
### 해시의 종류
#### 직접 번지 테이블(Direct-address Tables)
   1. 자료를 배열에 저장하여 사용
   2. key 들의 전체 집합이 크지 않을 때 사용
   3. 전체 집합이 너무 커지면 키들이 실제 사용하는 것에 비해 큰 배열이 필요한데 이는 메모리 낭비가 심하다.
#### 해시 테이블
   1. 집합에 비해 실제 사용되는 키들의 집합이 작을 때 사용.
   2. 직접 번지 테이블보다 메모리 공간이 적게 사용된다.
   3. 해시 함수를 이용하여 값을 산출하고 그 값을 이용하여 원하는 데이터를 알 수 있다.
   4. Hash Collision
      - 해시 함수를 만들다 보면 각각의 다른 값이 연산 결과가 같을 때가 있다. 이렇게 되면 원하는 값을 제대로 갖고 오지 못할 수도 있다.
      - 해결 방법
         1. Chaining
            1. 해시값이 같아도 링크드리스트를 이용해서 하나의 키값에 여러 데이터가 들어갈 수 있는 것.
         2. 개방주소법
            1. 해시 함수로 구한 값에 이미 값이 있다면, 비어있는 자리를 탐색해서 그 값을 조사하는 방법
               1. 빈 공간이 있을 경우 : 탐색키에 대한 값을 저장한다.
               2. 빈 공간이 없을 경우 : 빈 공간을 발견할 때까지 탐색을 반복한다.
         3. 효율적인 hash function의 사용. **djb2 권장** 
            ```
            unsigned long djb2(const char* str)
            {
                unsigned long hash = 5381; // base
                int c;
                while (c = *str++)
                {
                    hash = (((hash << 5) + hash) + c); // hash = hash * 33 + ascii code of str[i]
                }
                return hash % HASH_TABLE_SIZE;
            }
            ```


