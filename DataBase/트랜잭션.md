# 트랜잭션
## 정의
데이터 베이스의 상태를 변경시키기 위한 **작업 단위**  
따라서 쿼리문이 하나일 가능성은 매우 적다!!  
트랜잭션은 특징이 매우 중요하댜.
## 특징
- 원자성 : 트랜잭션은 데이터베이스에 전부 반영되던지 전혀 반영 안 되던지 둘중 하나이다.
- 일관성 : 한 트랜잭션 내에서는 결과 값이 모두 같아야한다.
트랜잭션이 진행중에 있다면, 진행중인 값으로 사용자가 데이터베이스 작업되는 것이 아니라 트랜잭션이 완료된 것으로 작업 및 사용이 가능하다.
- 독립성 : 트랜잭션 간에는 간섭이 불가능하다. 트랜잭션이 완료되기 전 까지는 다른 트랜잭션이 특정 트랜잭션을 참조할 수 없다.
- 영속성 : 트랜잭션이 완료되면 그 결과는 영구적으로 유지된다.
### 연산
- commit : 트랜잭션이 완료됨을 명시하는 연산으로 트랜잭션이 성공적으로 수행되고, 4가지 특징을 침해하지 않는다면 종료하는 연산이다.  
  해당 트랜잭션을 데이터베이스에 반영하겠다는 의미!
- rollback : 트랜잭션이 원활하게 수행되지 않았을 때 가장 최근에 저장된 트랜잭션으로 돌아가는 기능.
## 격리수준
### 격리 수준에 따라 발생하는 문제 - 정합성이 안 맞는 것
- Dirty Read : 트랜잭션이 완료되지 않았음에도 다른 트랜잭션에서 값을 확인할 수 있다.
- Non-Reapeatable Read : 한 트랜잭션에서 쿼리를 두 번 날리는데, 그 사이에 트랜잭션이 완료되어 두 값이 다른 현상
- Phantom Read : 한 트랜잭션의 일정한 범위에서 이전에 나오지 않았던 결과가 나오는 현상.
### 격리 수준
복수개의 트랜잭션이 사용될 때, 값의 일관성을 위해 격리 수준을 이용하여 제어한다.  
예를 들면,
```
1. 트랜잭션 A가 깃허브 user_id = 1인 사용자를 조회한다.
      select name from github_user where user_id = 1;
2. 트랜잭션 A가 user_id = 1인 사용자의 닉네임을 변경한다.
      update github_user set name = 'coco' where user_id = 1;
3. 커밋은 진행되지 않은 형태

이때, 트랜잭션 B가 깃허브 사용자를 조회한다면? 격리 수준에 따라 다른 결과가 나온다.
```
- Read Uncommited : commit이 완료되지 않은 데이터여도 읽을 수 있음  
-> 데이터가 롤백되면 값이 다르게 나타날 수 있다. **dirty read 발생** 
- Read Commited : commit이 완료된 데이터만 읽을 수 있음  
 -> 한 트랜잭션 (B) 내에 조회 결과가 다르게 나타날 수 있다. **Non-Repeatable Read 발생**
- Repeatable Read : 트랜잭션내에 조회한 데이터들은 몇 번 반복해도 값이 같다.  
 -> 트랜잭션 A에서 insert가 발생했고 완료되어 commit을 완료했을 때, 트랜잭션 B에서 이전에는 없던 값이 갑자기 나타날 수 있다.  
 (트랜잭션 B의 흐름에 통일성이 떨어지는 결과가 나타나는 것) **Phantom Read 발생**
- Serializable : 커밋이 완료되기 전까지는 락을 걸어 다른 트랜잭션이 접근할 수 없다.
  -> 정합성은 맞지만 속도가 매우 느림

|                  | Dirty Read | Non-Repeatable Read | Phantom Read |
|:----------------:|:----------:|:-------------------:|:------------:|
| Read Uncommitted |      O     |          O          |       O      |
|  Read Committed  |      X     |          O          |       O      |
|  Repeatable Read |      X     |          X          |       O      |
|   Serializable   |      X     |          X          |       X      |
## 전파 조건
> 부모 트랜잭션 : 자신을 호출한 메서드의 트랜잭션
- REQUIRE : 부모트랜잭션이 존재한다면 부모트랜잭션에 속하고, 존재하지 않는다면 트랜잭션을 생성한다.
- SUPPORTS : 부모트랜잭션이 존재한다면 부모트랜잭션에 속하고, 존재하지 않는다면 없이 수행
- MANDATORY : 부모트랜잭션이 존재한다면 부모트랜잭션에 속해서 수행, 부모트랜잭션이 없다면 예외가 발생한다.
- REQUIRE_NEW : 부모트랜잭션과 관계없이 새로운 트랜잭션을 생성한다.
- NEVER : 트랜잭션을 사용하지 않도록 한다. 부모트랜잭션이 있다면 예외를 발생시킨다.
- NESTED : 부모트랜잭션이 존재하면 부모트랜잭션안에 트랜잭션을 만든다. 부모트랜잭션의 커밋과 롤백에 현재 사용중인 트랜잭션은 영향을 받지만 현재 트랜잭션은 부모트랜잭션의 영향을 받지 않는다.
- NOT_SUPPORTED : 현재 트랜잭션이 종료될 때 까지 대기한 후 새로운 트랜잭션을 생성하고 실행하고 트랜잭션이 없다면 신규 트랜잭션을 생성하고 로직을 실행한다.

## locking
데이터베이스에 여러 사용자가 동시에 접근하는 상황에서 데이터의 무결성과 일관성을 지키기 위해 사용
- exclusive lock
데이터가 다른 곳에서 사용중이라면 읽기와 쓰기 모두 안 되는 것
- write lock
데이터가 다른 곳에서 사용중이라면 쓰기만 안 되고 읽기만 되는 것
