# JPA

## JPA를 사용하는 이유
- 단순한 쿼리의 경우 프로그래밍을 하는데 있어서 시간이 많이 소요되는데 이를 줄일 수 있다.
- ORM 이 변경되어도 유동적인 사용이 가능하다.

## 영속성
- JPA는 캐시라는 구조를 두고서 사용
- 1차 캐시에 값이 없으면 DB에서 값을 가져온다.
- DDL을 사용할 때, 먼저 1차 캐시에 값을 넣어두고 flush나 commit 행위를 거쳐야 실제 DB에 반영된다.
### 영속성 관리 - 내부 동작 방식

JPA에서 가장 중요한 2가지 

- 객체와 관계형 데이터베이스 매핑하기
- 영속성 컨텍스트
    - 엔티티매니저팩토리 :
    - 엔티티 매니저 : 내부적으로 커넥션을 이용해서 DB를 이용할 수 있도록 하는 것.
    - 영속성 컨텍스트
        - 엔티티를 영구적으로 저장하기 위한 환경으로 논리적인 개념임.
        - 엔티티 매니저를 통해서 접근한다.

- 엔티티의 생명주기
1. 비영속 (new)
    1.  영속성 컨텍스트에 생성된 상태
    2. 멤버 객체를 생성했을 때로 jpa와는 관련 없는 상태
2. 영속 (managed)
    1.  영속성 컨텍스트에 관리되는 상태로 영속 상태라 한다.
    2. 영속성컨텍스트를 통해 객체가 관리가 되는 것으로 db에 저장되어 DB에서 관리되는 것처럼 보이지만 아님.
    3. 실제 쿼리가 날라갈 때는 commit 시점!
3. 준영속 (detach)
    1. 영속성 컨텍스트에서 지워서 분리된 상태
4. 삭제 (remove)
    1. 실제 db를 지우는 상태
- 영속성 컨택스트의 이점
    - 1차 캐시
        - 조회 쿼리를 날렸을 때 최초로 조회되느 공간. 해당 공간에서 값을 찾지 못한다면,  DB에서 조회한다. 이후 조회한 결과를 1차 캐시에 저장한다.
        - 데이터 트랜잭션과 생명 주기를 같이한다.
        - 버퍼링 및 캐시가 가능하다.


### 영속 엔티티의 동일성 보장

1차캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 자원에서 제공.

### 엔티티를 등록할 때 트랜잭션을 지원하는 쓰기 지연.

- 엔티티 매니저는 데이터 변경시 트랜잭션을 시작한다.
- persist()
    - 쿼리를 날려 DB에 보내지 않음
    - 1차 캐시에 관련 쿼리를 생성하고, 쓰기 지연 SQL 저장소가 생긴다.
- commit() : insert 등 실제 쿼리를 날린다.

### 변경 감지

- 엔티티의 수정은 변경 감지(Dirty Checking) 를 통해서 이뤄진다.
- 과정
    
     1. flush()나 commit().
    
    1. 엔티티와 스냅샷을 비교한다.
        1. 스냅샷 : 값을 읽어온 최초의 시점.
    2. 쓰기 지연 저장소에 업데이트 쿼리를 작성하고, 커밋할 때 값이 반영된다.

### 엔티티 삭제

- commit() 시점에 delete 쿼리가 나간다.


# 플러시

- 영속성 컨텍스트의 변경내용을 데이터베이스에 반영
- 플러시 발생 (트랜잭션 발생과 유사)
    1. 변경을 감지한다.
    2. 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록한다.
    3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.

## 영속성 컨텍스트를 플러시하는 방법

1. 직접 호출 : em.flush()
2. 플러시 자동 호출
    1. 트랜잭션 커밋
    2. JPQL 쿼리 실행

플러시 모드 옵션

1. [FlushModeType.AUTO](http://FlushModeType.AUTO) : 커밋이나 쿼리를 실행할 때 플러시(기본 값)
2. FluModeType.COMMIT : 커밋할 때만 플러시.

플러시

- 영속성 컨텍스트를 비우지 않음.(1차 캐시가 지워지지 않음)
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 것
- 트랜잭션이라는 작업 단위가 중요 → 커밋 직전에만 동기화하면 됨.

## 준영속 상태

- 영속 → 준영속
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) : 다 빼버려서 영속성컨텍스트가 제공하는 기능을 사용못함.
- 영속성에서 관리를 원하지 않을 때 사용하며 영속성 컨텍스트에서 값이 제거된다.

### 준영속 상태로 만드는 방법!

- em.detach(entity) : 특정 상태만 준영속상태로 만들고자할 때
- em.claer() : 엔티티매니저에 있는 영속성을 통째로 지워버릴 때! 1차캐시를 통으로 지우고 다시 처음부터 영속성을 올린다.
- em.close : 데이터를 변경해도 변경도 안되고 아예 영속성을 닫아버리는 것

## QueryDSL

- 사용 경우
    - 동적으로 쿼리를 만들 때 사용
    - 조인이 필요할 때
- 설정 방법 (추후 작성)
- 조인시 주의 사항
    - 엔티티 관계에 신경써서 조인해야한다.
    
    ex) User - Diary : 1 : n → User.Diary, Diary 로 조인해야한다.
    
- Projection
    - 여러 개를 조회해서 값을 가져올 때, DTO에 바로 담을 수 있게 하는 것.
