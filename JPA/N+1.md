# N+1
## 현상
다대일 연관관계에서 값을 가져오기 위해 조인을 하게 되는데, 그 때 일에 해당하는 엔티티를 가져오기 위해 다에 매핑된 값들을 다 가져오는 것을 의미한다.
## 원인
JPA를 사용하면 먼저 Jpql을 자동으로 생성하는데 이때 연관관계가 걸려있어도 join이 바로 되지 않는다.
## 즉시로딩/ 지연로딩
### 즉시 로딩
DB에서 쿼리를 날려서 조회하는 것으로 사용하는 시점에 별도의 쿼리가 나가지 않는다.
```
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 10, nullable = false)
    private String name;

    @OneToMany(mappedBy = "user")
    private Set<Article> articles = Collections.emptySet();

    public Long getId() {
        return id;
    }
}

```

```
@Entity
public class Article {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 50, nullable = false)
    private String title;

    @Lob
    private String content;

    @ManyToOne
    private User user;
}

```

```
public class JpaTest {
    @Test
    @DisplayName("Eager type은 User를 단일 조회할 때 join문이 날라간다.")
    void test1(){
        // given
        User user = new User(1L, "JAE");

        // when
        userRepository.save(user);

        // then
        System.out.println(" ::: start ::: ");
        User find = userRepository.findById(1L).orElseThrow(RuntimeException::new);
        System.out.println(" ::: end ::: ");
        System.out.println(find.getName());
    }

    @Test
    @DisplayName("Eager type은 User를 전체 검색할 때 N+1 문제가 발생한다.")
    void test2(){
        // given
        User user = new User(1L, "JAE");

        // when
        userRepository.save(user);

        // then
        System.out.println(" ::: start ::: ");
        List<User> findList = userRepository.findAll();
        System.out.println(" ::: end ::: ");
    }
}

```
-> 여러 테이블을 조인하여 사용할 경우, 연관 관계에 있는 객체에 값이 없을 경우 그 값을 가져오기 위해 객체를 조회하게 된다. 이 때, N+1의 문제가 발생한다! -> fetch를 이용하여 해결

### 지연 로딩
프록시 객체를 확인하고, 실제 객체를 사용하는 시점에서 DB에 쿼리를 보내는 것. -> N + 1이 발생할 수 있는 것을 지연시키는 거지 발생을 막는 것은 아님

## 해결 방법
1.  Fetch Join
    1. 쿼리문을 만들어서 하는 것으로 한번에 된다.
    2. inner join의 형태
2. EntityGraph
    1. @EntityGraph 사용
    2. attributePaths 에 연관된 엔티티명을 넣어주면 함께 조회 가능하다.
    3. outer join의 형태
3. BatchSize를 제한두기
## 문제점
- paging
