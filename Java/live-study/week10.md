# 10주차 과제: 멀티쓰레드 프로그래밍
> 자바의 멀티쓰레드 프로그래밍에 대해 학습하세요.

## 학습 목록 
- [Thread 클래스와 Runnable 인터페이스](#Thread_클래스와_Runnable_인터페이스)
- [쓰레드의 상태](#쓰레드의_상태)
- [쓰레드의 우선순위](#쓰레드의_우선순위)
- [Main 쓰레드](#Main_쓰레드)
- [동기화](#동기화)
- [데드락](#데드락)
## Thread 클래스와 Runnable 인터페이스
### process와 Thread
### process
 - 프로그램을 실행한 것  
 - 프로그램을 실행하면 OS로부터 메모리를 할당받아 프로세스가 된다.
### Thread 
 - 프로세스의 실행 단위  
 - 프로세스의 일 부분이지만 독립적이며, 공통된 프로세스안에 있는 스레드들과 자원을 공유한다.
 - 두 개 이상의 스레드를 가지면 멀티스레드라고 한다.

Thread를 구현하려면 **Thread 클래스와 Runnable 인터페이스** 두 가지 방법을 이용한다.
### Thread 클래스
thread 사용하기 위해 상속받아야하는 클래스
언제? 다양한 thread의 기능을 오버라이딩하여 사용하고 싶을 때 사용.
### Runnable 인터페이스
thread를 사용하기 위해 사용해야하는 인터페이스.  
인터페이스를 사용하기 때문에, 재사용성이 높고, 코드의 일관성을 유지할 수 있다.  
run만 구현하면되는 인터페이스!  
Runnable 인터페이스를 구현했다면, Runnable 인터페이스를 구현한 인터페이스를 생성한 다음, 이 인스턴스를 Thread 클래스 생성자의 매개 변수로 제공해줘야한다.  
### Thread 클래스와 Runnable 인터페이스의 차이
Thread 클래스와 Runnable 인터페이스 둘다 스레드를 사용한다는 것이 같지만, 이외에 중요한 차이점이 있다.
 - Thread의 호출 방법
 Thread클래스를 상속받으면, 자손 클래스에서 조상인 Thread클래스의 메서드를 직접 호출 할 수 있지만,  
Runnable인터페이스를 사용하면 Thread클래스에서 static 메서드인 currentThread()를 호출하여 Thread에 대한 참조를 얻어와서 호출을 해야한다.  
 - Thread의 확장성
 확장성을 가질 것이냐 아니냐에 따라 어떤 것을 구현할 지 달라진다.  
 확장할 필요성이 있으면, Thread  Class를 사용하고, Thread에 큰 기능이 필요없다면, Runnable 인터페이스를 이용하여 구분만 해주면 된다.

## 쓰레드의 상태

## 쓰레드의 우선순위
쓰레드는 우선 순위를 매길 수 있는데 최고 값/최저 값을 정해주고 ㅁㅁㅁ한 메서드를 이용하여 우선순위를 정할 수 있다.
중요도에 따라 프로그램의 수행이 가능.
숫자가 높을 수록 우선 순위가 높다. 우선 순위가 높다는 것은 실행 되는 순서가 빠른 것이지 실행 시간이 빠른 것이 아니다.  
|||
|:---|:---:|
|MAX_PRIORITY | 쓰레드에 우선 순위를 매길 때, 제일 우선이 되는 값.  
|MIN_PRIORITY | 쓰레드에 우선 순위를 매길 때, 최소 값으로 우선 순위 제일 끝.  
|NORM_PRIORITY | 쓰레드에 우선 순위를 매길 때, 기본 우선 순위.  


getPriority(), setPriority() 메소드를 통해서 쓰레드의 우선 순위를 반환하거나 변경할 수 있다.
## Main 쓰레드
main 메서드 작업을 수햏하는 thread.
main메서드가 수행을 마치면 프로그램은 종료되지만, 다른 thread가 종료되지 않았다면 종료되지 않는다.
## 동기화
MultiThread Process환경에서 한 프로세스에는 여러 개의 스레드가 있을 수 있기 때문에, 그 쓰레드들은 자원을 공유하며 작업한다.  
이로 인해 쓰레드간 작업을 수행하며, 서로에게 영향을 주는 일이 당연하게 일어난다.  
  예를 들어, 한 프로세스에 Thread A와 Thread B가 있다. 두 Thread는 번갈아가며 작업하고, DATA 1을 공유하여, A Thread가 작업을 하다가   
DATA1을 변경시켜 Thread B의 값이 변경된 채 프로세스가 종료된다면, 의도하던 것과 결고가 달라질 수 있다.  
따라서 이런 **공유 데이터**에 에 접근 할 경우, Thread가 작업을 완료 할 때 까지 방해 받지 않도록 **임계 영역 (critical section)** 를 지정하여 프로세스가 의도대로 수행될 수 있다록 한다.  
한 Thread가 임계 영역에서 작업 중일 때, 다른 Thread가 작업을 수행하기 위해 들어오지 못 하도록 하는 것을 **동기화** 라고 한다.  
### 동기화 방법
#### synchronized를 이용
#### Lock와 COndition을 이용

## 데드락
프로세스들이 무한한 대기를 하는 상태




run() : thread 내용을 구현하는 메서드, run의 호출은 생성된 클래스에 선언된 thread를 호출하는 것
start() : thread를 호출하는 thread.
호출되었다고 바로 실행되는 것이 아니라, 실행 대기 상태가 되는 것.
한 번 실행이 종료되는 thread는 다시 start시킬 수 없다. -> IllegalThreadStateException
실제 thread가 실행되는 부분으로, thread가 작업을 실행하는데 필요한 호출 스택을 생성하고 거기에 run을 호출하여 호출 스택에 run이 들어가도록 한다.
*모든 thread는 독립적으로 수행되기 때문에 독자적인 스택영역을 가진다.  
thread가 종료되면 그 호출 스택도 소멸된다.*
호출 스택 최 상단에 있다고 실행중이라고 보장 할 수 없다.
