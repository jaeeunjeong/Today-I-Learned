# 자바 배열 복사
> 깊은 복사 얕은 복사 이해하기.
## 목록
- 정의
- 복사
### 정의
자바에서 말하는 배열이란 자료형들을 하나의 단위로 묶은 것을 의미한다.
### 복사 - 깊은 복사 얕은 복사
자바에서 배열은 레퍼런스타입이다.  
따라서 때때로 값을 변경했는데, 원하는 결과가 안 나오거나 값이 중복해서 나오는 등 어려움을 겪을 수 있다.  
배열은 레퍼런스 타입이기에 복사하는 과정에서 메모리 주소가 복사되기 때문이다.  
다른 변수를 쓰고 있다고 생각이 들지만 실제로는 하나의 객체만을 다루고 있는 것이다.  
이럴 때 깊은 복사를 통해 완전히 새로운 값을 만들어서 해결해주면 데이터만 복사하는 것이 가능하다.  
#### 깊은 복사 방법
얕은 복사는 '='를 이용해서 초기화 시켜주면 된다.(메모리 주소가 같게 복사된다.)  
깊은 복사 방법은 아래와 같다.
- Object.clone()
- Arrays.copyOf
- System.arraycopy
- Arrays.copyOfRange
- 일일이 복사
### 실습
#### 1차원 배열
```
	public static void test1() {
		int[] a = { 10, 20, 30, 40, 50 }; // 대조군
		int[] b = { 10, 20, 30, 40, 50 }; // 실험군
		int[] copyShallow = b;
		int[] copyDeep1 = b.clone();
		int[] copyDeep2 = Arrays.copyOf(b, b.length);
		int[] copyDeep2Part = new int[b.length];
		System.arraycopy(b, 0, copyDeep2Part, 0, 3);
		int[] copyDeep2Range = Arrays.copyOfRange(b, 3, b.length);
		int[] copyDeep3 = new int[b.length];
		for (int i = 0; i < b.length; i++) {
			copyDeep3[i] = b[i];
		}

		for (int i = 0; i < b.length; i++) {
			if (i == 1)
				copyShallow[i] = 61;
			if (i == 2)
				copyDeep1[i] = 62;
			if (i == 3)
				copyDeep2[i] = 63;
			if (i == 4)
				copyDeep3[i] = 64;
            // 출력 로직은 생략
		}
		// 일부분만 복사
		System.out.print("배열 크기는 그대로 가져가되, 배열 내용만 원하는 구간 복사 (System.arraycopy) : ");
		for (int t : copyDeep2Part)
			System.out.print(t + " ");
		System.out.println();
		System.out.print("일 부분만 자른 상태로 배열을 복사(copyOfRange) : ");
			for (int t : copyDeep2Range)
			System.out.print(t + " ");
	}
```
결과
```
origin 10 -> 10 10 10 10 10
origin 20 -> 61 61 20 20 20
origin 30 -> 30 30 62 30 30
origin 40 -> 40 40 40 63 40
origin 50 -> 50 50 50 50 64
배열 크기는 그대로 가져가되, 배열 내용만 원하는 구간 복사 (System.arraycopy) : 10 20 30 0 0 
일 부분만 자른 상태로 배열을 복사(copyOfRange) : 40 50 
```
2열은 1열과 같은 주소를 가리키게 복사되어 값이 동일하게 나오는 것을 알 수 있다.  
나머지는 값이 복사되어 다른 주소를 가리키며 원래 값과 다른 값이 출력된다.  
#### 2차원 배열
```
	public static void test2() {
		int[][] a = { { 11, 22, 33 }, { 44, 55, 66 }, { 77, 88, 89 } }; // 대조군
		int[][] b = { { 11, 22, 33 }, { 44, 55, 66 }, { 77, 88, 89 } }; // 실험군
		int[][] copyShallow1 = b;
		int[][] copyDeep1 = new int[3][3];
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 3; j++) {
				copyDeep1[i][j] = b[i][j];
			}
		}
		int[][] copyDeep2 = new int[3][3];
		for (int i = 0; i < 3; i++) {
			copyDeep2[i] = Arrays.copyOf(b[i], b[i].length);
		}
		int[][] copyDeep3 = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		for (int i = 0; i < 3; i++) {
			copyDeep3[i] = b[i].clone();
		}
		for (int i = 0; i < 5; i++) {
			int row = i / 3;
			int col = i % 3;
			if (i == 1)
				copyShallow1[row][col] = 61;
			if (i == 2)
				copyDeep1[row][col] = 62;
			if (i == 3)
				copyDeep2[row][col] = 63;
			if (i == 4)
				copyDeep3[row][col] = 64;
		}
      // 출력 로직은 생략
	}
```
결과
```
origin 11 22 33  ->   11 61 33    11 61 33   11 22 62   11 22 33   11 22 33 
origin 44 55 66  ->   44 55 66    44 55 66   44 55 66   63 55 66   44 64 66 
origin 77 88 89  ->   77 88 89    77 88 89   77 88 89   77 88 89   77 88 89 
```
1번과 2번의 (0, 1) 이 얕은 복사가 되어 값이 동일함을 알 수 있다.(주소 복사)  
나머지는 깊은 복사가 되어 값만 변경된 것을 알 수 있다.
