# 인증과 인가(허가)
## 인증(Authentication)
서비스를 이용하기 위해 사용자의 권한을 검증하는 것을 의미한다.(Login)
## 인가(/허가, Authorization)
- 사용자가 검증된 사용자인지 확인하는 것.  
- 매번 인증하지 않고 인가 과정을 거치는 이유  
	- 로그인 과정은 사용자 정보를 가져와서 복호화하고 검증하는 꽤나 복잡한 과정이다.  
 -> 따라서 매번 사용자의 ID와 Password를 이용해서 사용자를 검증하는 것은 비효율적이다.  

이 과정에서 세션, 쿠키, JWT가 이용된다.

## 세션/ 쿠키
 **서버 기반 인증 시스템**로, 브라우저의 쿠키랑 서버에서 갖고 있는 세션을 비교해서 사용자 정보를 검증한다.
### 인증 절차
1. 사용자가 로그인을 한다.
2. 서버는 로그인을 통해 사용자 정보를 획득하고  그 정보를 바탕으로 세션 저장소에 세션 ID를 만든다.
3. 세션 ID는 클라이언트 입장에서 쿠키에 저장되어 검증에 사용한다.
4. 클라이언트는 서비스를 이용할 때 인증이 필요하면 헤더에 쿠키를 담아서 보낸다.
5. 클라이언트가 보낸 쿠키를 바탕으로 서버는 검증하여 응답한다.

### 세션
서버에서 갖고 있는 정보
### 쿠키 
사용자에게 인증 정보를 브라우저에 저장하는 것.

### 장점
서버에서 정보를 갖고 있기에 관리하기 쉽다.(statable)
### 단점
- 너무 많은 사용자가 있을 경우 서버에 부하가 심하다.  
- 서버가 재시작되면 이전의 세션이 종료된다.  
- 서버가 분산된 환경이라면 관리가 더 복잡하다.  
- 해커가 쿠키를 탈취하여 사용한다면? 서버는 탈취된 정보인지 확인이 불가능하다.  
  -> 쿠키에 유의미한 정보가 없기 때문.
## JWT(Json Web Token)
서버에 저장하지 않는 방식의 인가 방식  
브라우저의 헤더에 정보를 넣어서 검증한다.
### 인증 절차
1. 사용자는 로그인을 한다.
2. 로그인이 완료되면 서버는 클라이언트에게 토큰을 발급한다.
3. 클라이언트가 서비스 이용시 인증이 필요하다면 헤더에 토큰을 실어 보낸다.
4. 서버는 클라이언트가 보낸 토큰을 기반으로 복호화하여 요청이 올바른지 확인한다.
5. 결과에 맞게 응답한다.
### 형식
```
hhhh.ppppp.sssss
```
- h : **Header** : 암호화 방식과 타입 정보등이 존재
- p : **Payload** : 서버에 전송할 실제 데이터들.
- s : **Verify Signature** Header, Payload, Secret Key를 바탕으로 암호화한 값.  
secure base64로 인코딩 한다.

### 장점
stateless 하다. -> 서버에 부하가 적음. 서버에서 관리하지 않기에 간편.  
확장성이 좋다. -> 다른 인증 시스템에 접근 가능.  
### 단점
이미 발급된 토근은 일정 기간이 지나기 전 까지는 지울 수 없다.   -> 만약 정보가 유출이 염려된다면? Access Token의 유효기간을 짧게하고 Refresh Token이라는 새로운 토큰을 발급한다.
### Access Token
최초로 생성된 토큰
### Refresh Token
Access Token과 같이 발급된 토큰으로 유효기간이 더 길다.  
Access Token의 기간이 만료되거나 의심스러우면 Refresh Token의 최초 발급 시점이나 IP 주소등을 확인하여 재발급해준다.  
일반적으로 15일을 잡는다.  
서버의 DB에 저장해서 값을 비교하여 확인해준다.  
secure httponly를 이용하면 https에서 사용되기에 비교적 안전하게 사용할 수 있다.
### Refresh Token이 추가된 검증.
1. 로그인 요청
2. 로그인에 성공하면 JWT(Access Token, Refresh Token)를 발급
   1. Access Token는 헤더에 실어 브라우저에게 전송
   2. Refresh Tokend은 DB와 같은 안전한 저장소에 저장.
3. 이후 브라우저는 발급된 Access Token을 이용해서 인증받음.
4. Access Token이 만료된다면?  
   1. 로그인 시 검증을 못하며 Refresh Token을 확인한다.
   2. 적절하다면 Access Token을 발급. 아니라면 거절.

